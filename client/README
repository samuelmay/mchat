Threads
-------

* Main thread: Console loop. Dispatches commands, as detailed in 'COMMANDS'
  section.
  FILES: main.c, commands.c, client.c

* Registration thread: simply throws a UDP packet at the registration server
  every 30 seconds, updates the user list with the response (carefully!), and
  goes back to sleep (actually, waits on a condition variable with a 30s
  timeout, so we can force an update right now by activating the condition
  variable).
  FILES: registration.c

* Incoming connection server: uses select() to wait for a readable socket, and
  either a) accepts a new connection and notifies user b) cleans up a closed
  socket or c) receives message and writes to the console.
  FILES: server.c

Resources
---------

(Globally visible, require mutex/locks to access)

User list: Main list of users. Code in user.c and user.h An array of 'struct
user', sorted by username, along with an int 'num_users' holding the number of
entries. Two search functions exist: lookup_user(), which searches for a
username using binary search (fast!), and lookup_socket(), which searches for a
file descriptor linearly (slow, used only once in server.c when a connection is
closed).

Output console: stdout. We want all printing to the screen to be in coherent
blocks. (TODO possibly lock when reading stdin as well?)

Startup
-------

* parse command line as per 'options.c', putting results in options struct.

* create and bind listening socket. if no port was specified, get random free
  port.

* start server thread:

* start registration thread

* start command loop.

Commands
--------

* list: print out the user list
  FILES: user.c
  FUNCTIONS: print_user_list()
  PROCEDURE: Loop through user list and print to console.

* update: force update of user list
  FILES: main.c
  FUNCTIONS:
  PROCEDURE: set condition variable for registration thread so it wakes and
  updates now.

* connect <username>: initiate connection with someone on the user list
  FILES: client.c
  FUNCTIONS: connect_user()
  PROCEDURE: Check if that's a logged-on user; Check if we don't already have a
  connection; if not, create connection and set 'connected' flag.

* disconnect <username>: disconnect with someone
  FILES: commands.c
  FUNCTIONS: disconnect()
  PROCEDURE: Check if we have a connection, if so, clear 'connected' flag in
  the user entry; the server thread will garbage collect the socket.

* msg: send message to all connected users. TODO: allow messages to individual 
  connected users.
  FILES: client.c
  FUNCTIONS: broadcast_message().
  PROCEDURE: send buffer to each open socket in turn.

* quit/bye/Ctrl-D: exit
  FILES: main.c
  FUNCTIONS:
  PROCEDURE: kill all threads, close all open sockets.

* block/unblock: block a user from connecting to you
  FILES: commands.c
  FUNCTIONS: block() unblock()
  PROCEDURE: if a valid user, set/clear 'blocked' flag in user entry.

* help: self-explanatory.
  FILES: commands.c
  FUNCTIONS: help()
  PROCEDURE: print out help.

